# 제어문

## Block문

코드를 묶는 가장 기본적인 문법 (**{ }**)

일반적으로 제어 흐름 문과 함께 사용됨

**ECMAScript2015 이전의 JavaScript는 블록 범위를 가지고 있지 않음**
- Block 내에서 선언한 변수는 블록을 넘어 변수가 위치한 함수 혹은 스크립트에 영향을 끼치게 됨

- let, const로 블록 범위를 제한할 수 있음

## 조건문

- if...else
    - 특정 조건이 참인 경우 문장을 실행하기 위해 if 문을 사용

    - 선택적으로 조건이 거짓인 경우 문장을 실행하기 위해서는 else 절을 사용

    - 순서대로 나열된 여러 조건을 가지고 else if를 사용

    - 거짓으로 취급하는 값
        - false
        
        - undefined

        - null

        - 0

        - NaN

        - empty string ("")
- switch

    - 프로그램이 표현식을 평가하고 값을 조건과 비교
    
    - 값이 일치한다면, 프로그램은 각 조건의 하위 문장을 실행

    - 프로그램은 주어진 값과 일치하는 case 라벨을 찾고, 그 구문을 실행 (없다면 default)

    - break로 탈출

## 예외처리문

- throw문

- try...catch문

    - 시도할 블록을 표시하고, 예외가 발생하였을때, 하나 이상의 반응을 명시

    - 하나 이상의 문장을 포함한 try 블록과, 예외가 발생하였을때 처리할 문장을 포함한 0개 이상의 catch 블록으로 구성됨

    - finally 블록은 try 블록과 catch 블록의 시행이 끝나고 try...catch 문법 다음의 문장이 시행 되기 전에 시행됨

## Promise

프로미스 : 자바스크립트 비동기 처리에서 사용되는 객체

(비동기 처리 : 특정 코드의 실행이 완료될 때까지 기다리지 않고 다음 코드를 먼저 수행하는 자바스크립트의 특성)

    new Promise = (executor);

excutor : resolve및 reject 인수를 전달할 실행 함수

모든 작업을 끝내면 resolve를 호출, 에러가 나면 reject를 호출

프로미스의 3가지 상태

1. 대기 : 이행하거나 거부되지 않은 초기 상태

2. 이행 : 연산이 성공적으로 완료됨

3. 거부 : 연산이 실패함

에러 처리 방법

1. then()의 두 번째 인자로 처리하는 방법

2. catch()를 사용하는 방법

## 궁금한 점

프로미스 에러 처리 방법에서 catch()를 사용하는 법은 알겠는데, then()의 두 번째 인자로 처리하는 방법에 대해서 잘 모르겠다.

-> 에러를 잡는 함수를 새로 만들면 됨

## 회고

다른 제어문은 C에서 사용했던 것과 형식이 비슷해서 잘 알겠는데, 프로미스가 조금 어렵다. 프로미스는 좀 더 공부해야겠다
